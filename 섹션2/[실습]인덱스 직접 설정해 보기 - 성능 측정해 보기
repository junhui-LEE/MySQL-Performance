이 부분에서 성능을 측정하기 위해서 쓰는 MySQL쿼리의 WITH cte AS문과 WITH RECURSIVE cte AS문이 나오는데
이 쿼리에 대해서 깊이 있게 학습을 했다. (해당 임시테이블 만드는 쿼리에 대해서 전체 이해 했으며 안보고 쿼리 작성 가능하다.)

아무튼 해당 강의 "[실습]인덱스 직접 설정해 보기 - 성능 측정해 보기" 에 대한 실습 내용과
임시테이블 만드는 쿼리 에 대해서 학습한 내용을 전부 여기에 올려 본다.
**************************************************************************************************************************************************************
1) "[실습]인덱스 직접 설정해 보기 - 성능 측정해 보기"에서 학습한 내용들(주로 책을 봤기 때문에 책을 올릴수는 없지만 아무튼 책으로 훨씬 꼼꼼하게 학습했다.)

1. 테이블 생성
DROP TABLE IF EXISTS users; -- 기존 테이블 삭제

CREATE TABLE users(
	id INT AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(100),
	age INT
);

-- 2 100만 건의 랜덤 데이터 삽입
-- 인덱스 설정 전후의 성능 차이를 비교하기 위해 랜덤 데이터를 넣어보자.

-- 높은 재귀(반복) 횟수를 허용하도록 설정
-- (아래에서 생성할 더미 데이터의 개수와 맞춰서 작성하면 된다.)
SET SESSION cte_max_recursion_depth = 1000000;
-- cte_max_recursion_depth : MySQL에서 재귀를 통해 만든 임시테이블(cte, Common Table Expression)의 최대 깊이를 설정하는 변수
--                           이것이 테이블 이름 처럼 보일 수 있지만 SQL실행에 영향을 주는 설정 변수 이다. 값을 1000000으로 설정했다.

-- 더미 데이터 삽입 쿼리
INSERT INTO users(name, age)
WITH RECURSIVE cte(n) AS(
	SELECT 1
	UNION ALL
	SELECT n+1 FROM cte WHERE n<1000000
)
SELECT 
	CONCAT('User', LPAD(n, 7, '0')),  -- 'User' 다음에 7자리 숫자로 구성된 이름 생성
	FLOOR(1 + RAND()*1000) AS age     -- 1부터 1000 사이의 랜덤 값으로 나이 생성
FROM cte;

-- 잘 생성 되었는지 확인
SELECT COUNT(*) FROM users;

SELECT * FROM users;
SELECT * FROM users WHERE age=23;
-- "DBeaver -> Window -> Show View -> Query Manager"을 누르면 Query Manager 위젯이 나오는데 이 위젯에서 성능을 확인할 수 있다.
-- SELECT * FROM users WHERE age=23; 을 계속 실행해 보면 가장 빠른 속도는 0.237s 이고 가장 늦은 속도는 0.770s이다. 그리고 평균적으로 한.. 0.333s정도 걸린다.
-- DBeaver에서 자동으로 limit 200으로 설정이 되어 있기 때문에 쿼리 실행시에 자동으로 LIMIT 0, 200 이 붙는다. 나는 1000000데이터를 성능조회 할 것이기 때문에 200으로 설정
-- 되어 있는 것을 1000000으로 고쳤다.

-- 이렇게 여러번 SELECT * FROM users WHERE age=23; 을 실행해 봄으로서 대략 성능이 0.333s 정도 걸리는 것을 확인 했다.
-- 그리고 나서 인덱스를 적용시켜 보자.

-- 인덱스 생성
-- CREATE INDEX 인덱스명 ON 테이블명 (컬럼명);
CREATE INDEX idx_age ON users(age); -- 인덱스 명은 idx를 쓰고 인덱스를 걸어둘 컬럼명을 써주는 방식을 많이 사용한다.
-- SHOW INDEX FROM 테이블명;
SHOW INDEX FROM users; -- 인덱스가 생성되었는지 확인하는 방법

-- 데이터 다시 조회해 보고 SQL문 실행 소요시간을 측정해 보자
SELECT * FROM users WHERE age=23;
SELECT COUNT(*) FROM users WHERE age=23;
-- 오호 엄청 빨라졌다. 0.036s, 0.038s, 0.006s, 0.038s, 0.047s, 0.051s, 0.092s 정도 걸린다.
-- 평균 0.055s라고 하자 그냥

-- 인덱스를 적용하기 전의 성능 : 0.333s
-- 인덱스를 적용한 후의 성능 : 0.055s
-- 대략 5~6배 정도 성능이 좋아 졌다.
**************************************************************************************************************************************************************
2) 임시테이블 만드는 쿼리 학습 - WITH cte AS문, WITH RECURSIVE cte AS문
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- WITH cte AS 문에 대해서 학습해 보자
-- WITH cte AS 문 : MariaDB에서 임시테이블을 사용하는 방법은 몇가지가 있는데 그중 하나 이다.
-- CTE란? (Common Table Expressions) : 쉽게 말해서 "임시테이블 이름" 이라고 생각하면 된다.
-- 여기서 선언한 임시테이블 이름인 cte는 개발자가 칭하는 명이다. ddd 라고 써도 된다.
WITH cte AS(
-- 이 괄호 안에 내가 원하는 테이블의 데이터를 가져오거나 상수값을 select하거나 해서 테이블 구조를 만들어 놓으면 그것이 임시테이블이 되는것이다.
-- 현재 임시테이블 이름은 cte이다. 그리고 괄호가 끝났다고 해서 명령이 끝난것이 아니고 꼭 괄호() 다음에 select문을 써서 임시테이블을 사용하는
-- select 쿼리가 있어야 한다. 그래야 하나의 명령이 끝난다. 임시테이블 만들고 조회까지 해야 WITH cte AS문의 명령이 끝난다.
-- 괄호 다음에 있는 select문이 끝남으로서 WITH cte AS문 하나의 전체 명령이 끝나면 내가 임시로 만들어 놓은 테이블(여기서는 cte)테이블은
-- 바로 사라진다. 달리말해서 동시간대에 다른 사용자가 cte를 만들어서 언제든지 사용 가능하다는 얘기이다.
	SELECT 1, 23
	UNION ALL 
	SELECT 3, 41
	-- 각각의 레코드 1개,1개 더해서 레코드 2개의 테이블 구조가 나온다. 컬럼명은 첫번재 레코드에서 결정된다. 1,2가 데이터 레코드인 동시에
	-- 컬럼명들이 된다. 컬럼명을 바꾸고 싶으면 select 1 as col, 2 as val 이렇게 써주면 된다.
)
SELECT * FROM cte;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- WITH cte 문 뒤에 컬럼 명시 또는 'AS 컬럼별칭' 문법으로 정의
WITH cte(col, val) AS(
-- 컬럼을 명시하고 싶을때 임시테이블 옆에 컬럼명들을 써도 되고
-- SELECT 'a' AS col, 1000 AS 1000 이렇게 선언해도 된다.
	SELECT 'a', 1000
	UNION ALL
	SELECT 'b', 2000
)
SELECT * FROM cte;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2개 이상의 임시테이블 선언(두개 이상의 임시테이블을 동시에 쓸 수 있다.)
WITH 
cte1 AS(
	SELECT 1, 2
	UNION ALL
	SELECT 3, 4
),
cte2 AS(
	SELECT 'a', 1000
	UNION ALL
	SELECT 'b', 2000
)
-- 마지막에 위에서 만든 임시테이블들을 가져다가 쓰는 것이다.
-- SELECT * FROM cte1
-- UNION ALL
SELECT * FROM cte2;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 순차 선언된 임시테이블 재 호출, cte3과 cte4의 선언 순서는 뒤바뀔 수 없음
WITH 
cte1 AS(
	SELECT 1, 2
	UNION ALL
	SELECT 3, 4
),
cte2 AS(
	SELECT 'a', 1000
	UNION ALL
	SELECT 'b', 2000
),
cte3 AS(
	SELECT 'c', 3000
	UNION ALL
	SELECT 'd', 4000
),
cte4 AS(
-- 임시테이블 cte4를 만들때 위에 선언한 임시테이블을 가져다가 쓸 수 있다.(만들 수 있다.)
	SELECT * FROM cte2
	UNION ALL
	SELECT * FROM cte3
)
SELECT * FROM cte4;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 임시테이블 생성문 내부에서 다시 임시테이블을 생성해 활용하는 경우
WITH
cte2 AS(
	SELECT 'a', 1000
	UNION ALL
	SELECT 'b', 2000
),
cte3 AS(
-- WITH cte AS 문 안에 WITH cte AS문을 또 써서 선언할 수 있다.
	WITH cte3_inner AS(
		SELECT 'z', 9999
	)
	SELECT * FROM cte3_inner
),
cte4 AS(
	SELECT * FROM cte2
	UNION ALL
	SELECT * FROM cte3
)
SELECT * FROM cte4;

지금부터는 WITH RECURSIVE cte AS문에 대해서 학습해 보다.
-- WITH cte AS문과 WITH RECURSIVE cte AS문 둘다 임시테이블을 만드는 일종의 개념이다.
-- WITH ctee AS문 간츤 경우에는 정적인 기존의 테이블들, 혹은 select해서, 그렇게 테이블구조를
-- 만들고 만들어진 테이블 구조를 통해서 임시테이블을 만들었다고 하면 
-- WITH RECURSIVE cte AS문은 동적이다.
-- 즉, FROM해서 자기자신(테이블구조)을 호출하는 과정에서 1을 더해서 가져온다던가 이런식으로
-- 발생하는 데이터를 가지고 또 다른 데이터 집합을 만든다. 그리고 그 또 다른 데이터 집합을 이용해서
-- 임시테이블을 만들게 된다. 그래서 동적이라고 얘기할 수 있다.

WITH RECURSIVE cte AS(
-- cte(임시테이블 이름)를 선언하는 괄호 안에서 cte를 다시 호출하다. 이것이 재귀쿼리, 순환쿼리이다.
	SELECT 1 AS n          -- UNION ALL 이전은 딱 한번 실행된다.(cte테이블 안에 n이라는 컬럼의 첫번째 값은 1이다.)
	UNION ALL              -- n  --> 이런 테이블구조가 나온다. 그리고 변수 n에는 1이 저장되어 있다. 그 다음에 UNION ALL
	SELECT n+1 FROM cte    -- 1      아래에 있는 SELECT n+1 FROM cte문을 보자, 지금까지(UNION ALL 이전)만든 테이블 구조의 row의 수는 1개이다.
	WHERE n<5              -- 그리고 n+1의 값은 2가 된다.  
)                          -- n+1 --> 따라서 이런 테이블 구조가 나온다. 
SELECT * FROM cte;         -- 2
                           -- 그리고 UNION ALL로 인해서
                           -- n  --> 이런 테이블구조가 나온다. UNION ALL로 인해서 n+1한것이 컬럼명이 n인 row의 값으로 2가 들어간 꼴이 된것이고
                           -- 1      n에는 2가 저장된다. 이때 SELECT n+1 FROM cte문을 보자 n의 값이 2로 바뀌었기 때문에 row가 1개인 cte를
                           -- 2      참조해서 상수를 조회하는 쿼리(SELECT n+1 FROM cte)를 테이블 구조화 하면 n+1/2 의 모양이 아니라 n+1/3의  
                           --        모양이 맞다. 따라서 SELECT n+1 FROM cte가 또 호출되어서 n+1/2의 테이블구조를 만든다. 그리고나서                                                               
                           --        UNION ALL이 실행된다. 그럼 n+1/3한것이 컬럼명이 n인 row의 값으로 3이 들어간 꼴이 되고 n에는 3이 저장된다.                                                               
                           -- n  --> 따라서 이런 테이블구조가 나온다. 이런식으로 계속 n<5까지 반복하면 n이 4일때 n+1/5가 만들어지고 UNION ALL이
                           -- 1      실행되어서 결국에는 n   이렇게 테이블 구조가 만들어지고 그 후 n이 5가 된다. n이 5가 되면 WHERE n<5
                           -- 2                    1   (n이 5보다 작으면 true)가 false이고 더이상 실행되지 않고 최종 테이블 구조인
                           -- 3                    2   <-- 이것이 임시테이블이 되는 것이다.
                           --                      3
                           --                      4
                           --                      5

-- 디비버가 컴파일 잘 못한다. 주석 전부 제거하고 실행하면 정상적으로 출력된다.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 책에 필기한 내용 정리(한번또 써본다.)
WITH RECURSIVE cte AS(
-- 괄호 안인 여기에 데이터 집합을 정의하는 부분을 선언하는데 두가지로 나뉜다. 괄호 안에서 UNION ALL이전과 UNION ALL이후로 나뉜다.
-- UNION ALL 이전은 해당 임시테이블 cte의 첫번째 레코드와 컬럼명을 정의 한다. UNION ALL 이후에는 해당 cte 테이블이
-- 가지고 있는 데이터 집합 중에서 두번째 건부터 마지막 건을 의미한다
	SELECT 1 AS n
	UNION ALL
	SELECT n+1 FROM cte  -- 여기서 cte(임시테이블)을 호출할 때에는 UNION ALL 앞에 있는 문장, 
	WHERE n<5            -- 즉, SELECT 1 AS n에서 만들어진 테이블 구조를 임시테이블(cte)로 간주한다.
)                        -- 그리고 UNION ALL 이후인 여기 SELECT문 부터는 방금전에 가져와서 만들어진 데이터 값, 즉, n
SELECT * FROM cte;       -- 값을 계속해서 호출하는 것이다.(SELECT n+1 FROM cte를 보면 n값에 1을 더하라고 쓰여 있다.)
                         -- 무한대로 SELECT n+1 FROM cte를 호출하지는 않고 WHERE절이 그 조건의 끝이다. 
                         -- WHERE절이 참일때 까지만 자기 자신을 계속 호출한다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------
WITH RECURSIVE cte AS(       ---- (1) 재귀(순환)쿼리에 사용될 임시 테이블명과(cte) 컬럼명(생략가능)을 명시합니다.
	SELECT 1 AS n            ---- (2) UNION 이전 쿼리~ (1)부분에 컬럼녕이 없다면 이곳에서 정의되며(AS n 등) 첫 번째 데이터도 함께 생성합니다.
	UNION ALL
	SELECT n+1 FROM cte
	WHERE n<5                ---- (3) UNION 이후 쿼리~ 임시 테이블에 저장될 데이터를 조건절을(WHERE n<5)이용해 생성합니다.
)                            --       자기자신을 호출하는 코드가 여기에 나온다.
SELECT * FROM cte;           ---- (4) 임시로 생성된 'cte' 테이블을 대상으로 실행되는 SQL 쿼리입니다.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 문법과 예제
WITH RECURSIVE cte AS(
	SELECT 1 AS n
	UNION ALL
	SELECT n+1 FROM cte
	WHERE n<5
)
SELECT * FROM cte;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- "RECURSIVE 임시테이블" 뒤에 컬럼을 직접 명시
WITH RECURSIVE cte(n) AS(
	SELECT 3 
	UNION ALL
	SELECT n+1 FROM cte
	WHERE n<5
)
SELECT * FROM cte;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- AS 문 안에 재귀호출 과정이 없어도 된다. (그럼 WITH cte AS() 문과 똑같아 진다.)
WITH RECURSIVE cte AS(
	SELECT 1 AS rno
)
SELECT * FROM cte;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 피보나치 수열
-- (4) 피보나치 수열이란 첫재 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열
-- 1, 1, 2, 3, 5, 8, 13, ...
WITH RECURSIVE fibonacci(col1, col2) AS(
	SELECT 1, 1
	UNION ALL
	SELECT col2, col1+col2 FROM fibonacci 
	WHERE col2<50
)
SELECT * FROM fibonacci;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 24시간에 대해 응용(1,2,3,4, ... 23)
WITH RECURSIVE time24hr AS(
	SELECT 0 AS hr
	UNION ALL
	SELECT hr+1 FROM time24hr WHERE hr<23
)
SELECT * FROM time24hr;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- WITH RECURSIVE cte AS 문이 적용된 임시테이블을 여러개 만들수 있다.
-- 이때 두번째 부터의 임시테이블에서는 WITH RECURSIVE를 생략해야 한다.
WITH RECURSIVE cte AS(
	SELECT 1 AS rno
	UNION ALL
	SELECT rno+1 FROM cte WHERE rno<10
),
cte2 AS(
	SELECT 11 AS rno
	UNION ALL
	SELECT rno+1 FROM cte2 WHERE rno<15
),
cte3 AS(
	SELECT 21 AS rno
)
SELECT * FROM cte
UNION ALL
SELECT * FROM cte2
UNION ALL
SELECT * FROM cte3;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- WITH RECURSIVE cte AS 문을 잘못 하용하는 경우
-- 여러개의 임시테이블을 설정할때에는 처음 WITH를 쓰는 쪽에서 RECURSIVE를 쓰냐 마냐에 따라서
-- 그다음 나오는 임시테이블 전체에 RECURSIVE를 허용하냐 안하냐가 결정된다. 
-- 만일 처음 나오는 WITH에서 RECURSIVE를 쓰지 않고 WITH cte AS()문을 사용한다면
-- 그 후에 나오는 임시테이블들은 모두 WITH cte AS문을 따른다. 그 후에 나오는 임시테이블에
-- RECURSIVE를 쓰면 에러 난다. 아래와 같은 코드는 에러코드이다.
WITH cte3 AS(
	SELECT 21 AS rno 
),
RECURSIVE cte4 AS(
	SELECT 1 AS rno
	UNION ALL
	SELECT rno+1 FROM cte4 WHERE rno<10
)
SELECT * FROM cte3
UNION ALL
SELECT * FROM cte4;
